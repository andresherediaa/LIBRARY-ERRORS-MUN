"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogService = void 0;
const winston = __importStar(require("winston"));
const LogstashTransport = require("winston-logstash/lib/winston-logstash-latest");
class LogService {
    constructor({ serviceName, logstashHost, logstashPort, maxConnectRetries = -1, sslEnable = false, level = "info", stringify = false, prettyPrint = false, showLevel = true, silent = false, enableConsole = false, callback, }) {
        try {
            const transports = [
                new LogstashTransport({
                    host: logstashHost,
                    port: logstashPort,
                    ssl_enable: sslEnable,
                    max_connect_retries: maxConnectRetries,
                }),
            ];
            if (enableConsole) {
                transports.push(new winston.transports.Console());
            }
            this.logger = winston.createLogger({
                level,
                format: winston.format.combine(winston.format.timestamp(), winston.format.errors({ stack: true }), winston.format.splat(), winston.format.json({ space: prettyPrint ? 2 : 0 }), winston.format.printf(({ level, message, timestamp, stack }) => {
                    const obj = {
                        timestamp: timestamp,
                        level: level.toUpperCase(),
                        message: message,
                        serviceName: this.serviceName,
                    };
                    if (stack) {
                        obj.stack = stack;
                    }
                    return JSON.stringify(obj, null, prettyPrint ? 2 : 0);
                })),
                transports,
                silent,
                exitOnError: false,
            });
        }
        catch (e) {
            console.log("Cannot establish connection to logstash", e);
        }
        this.serviceName = serviceName;
        this.callback = callback;
    }
    static getInstance({ serviceName, logstashHost, logstashPort, maxConnectRetries = -1, sslEnable = false, level = "info", stringify = false, prettyPrint = false, showLevel = true, silent = false, callback, }) {
        if (!LogService.instance) {
            LogService.instance = new LogService({
                serviceName,
                logstashHost,
                logstashPort,
                maxConnectRetries,
                sslEnable,
                level,
                stringify,
                prettyPrint,
                showLevel,
                silent,
                callback,
            });
        }
        return LogService.instance;
    }
    callCallback(level, message) {
        this.callback(level, message);
    }
    log(level, message, meta) {
        const levels = ["error", "warn", "debug"];
        const defaultLevel = "log";
        if (this.callback) {
            this.callCallback(levels.includes(level) ? level : defaultLevel, message);
        }
        this.logger.log(level, message, Object.assign(Object.assign({}, meta), { serviceName: this.serviceName }));
    }
    info(message, meta) {
        this.log("info", message, meta);
    }
    error(message, meta) {
        this.log("error", message, meta);
    }
    warn(message, meta) {
        this.log("warn", message, meta);
    }
    debug(message, meta) {
        this.log("debug", message, meta);
    }
    setLevel(level) {
        this.logger.level = level;
    }
    setStringifyLogs(prettyPrint = false) {
        this.logger.format = winston.format.combine(winston.format.timestamp(), winston.format.errors({ stack: true }), winston.format.splat(), winston.format.json({ space: prettyPrint ? 2 : 0 }), winston.format.printf(({ level, message, timestamp, stack }) => {
            const obj = {
                timestamp: timestamp,
                level: level.toUpperCase(),
                message: message,
                serviceName: this.serviceName,
            };
            if (stack) {
                obj.stack = stack;
            }
            return JSON.stringify(obj, null, prettyPrint ? 2 : 0);
        }));
    }
    setSilent(silent) {
        this.logger.silent = silent;
    }
    logUnhandledErrors() {
        process.on("unhandledRejection", (reason, promise) => {
            this.logger.error("Unhandled Rejection at:", promise, reason);
        });
        process.on("uncaughtException", (error) => {
            this.logger.error("Uncaught Exception thrown:", error);
        });
    }
    logStackTrace(error) {
        this.logger.error(error.stack);
    }
    logNestedObject(obj, maxDepth = 1) {
        const util = require("util");
        this.logger.info(util.inspect(obj, { depth: maxDepth }));
    }
    logWithContext(context, level, message, meta) {
        const contextLogger = this.logger.child({ context });
        contextLogger.log(level, message, Object.assign(Object.assign({}, meta), { serviceName: this.serviceName }));
    }
}
exports.LogService = LogService;
//# sourceMappingURL=log-service.js.map